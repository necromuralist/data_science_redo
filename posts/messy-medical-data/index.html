<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Cleaning up some messy medical data.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Messy Medical Data | Data Science With Python Re-Do</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://necromuralist.github.io/data_science_redo/posts/messy-medical-data/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script><meta name="author" content="Cloistered Monkey">
<link rel="prev" href="../international-olympiad-in-informatics/" title="International Olympiad in Informatics" type="text/html">
<meta property="og:site_name" content="Data Science With Python Re-Do">
<meta property="og:title" content="Messy Medical Data">
<meta property="og:url" content="https://necromuralist.github.io/data_science_redo/posts/messy-medical-data/">
<meta property="og:description" content="Cleaning up some messy medical data.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-07-23T12:12:57-07:00">
<meta property="article:tag" content="textprocessing datacleaning">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-default navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://necromuralist.github.io/data_science_redo/">

                <span id="blog-title">Data Science With Python Re-Do</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>
                </li>
<li>
<a href="../../rss.xml">RSS feed</a>
            </li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Projects <b class="caret"></b></a>
            <ul class="dropdown-menu">
<li>
<a href="../../machine-learning-projects/">Machine Learning</a>
                    </li>
<li>
<a href="https://necromuralist.github.io/p5_explorations/">P5 Explorations</a>
                    </li>
<li>
<a href="https://necromuralist.github.io/tddmachinelearning/">TDD Machine Learning</a>
                    </li>
<li>
<a href="https://necromuralist.github.io/student_intervention/">Student Intervention Project</a>
                    </li>
<li>
<a href="https://necromuralist.github.io/boston_housing/">Boston Housing Project</a>
                    </li>
<li>
<a href="https://necromuralist.github.io/data_science/">Data Science With Python</a>
            </li>
</ul>
</li>
</ul>
<!-- Google custom search --><form method="get" action="https://www.google.com/search" class="navbar-form navbar-right" role="search">
<div class="form-group">
<input type="text" name="q" class="form-control" placeholder="Search">
</div>
<button type="submit" class="btn btn-primary">
	<span class="glyphicon glyphicon-search"></span>
</button>
<input type="hidden" name="sitesearch" value="https://necromuralist.github.io/data_science_redo/">
</form>
<!-- End of custom search -->


            <ul class="nav navbar-nav navbar-right">
<li>
    <a href="index.org" id="sourcelink">Source</a>
    </li>

                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Messy Medical Data</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    Cloistered Monkey
            </span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2018-07-23T12:12:57-07:00" itemprop="datePublished" title="2018-07-23 12:12">2018-07-23 12:12</time></a></p>
            
        <p class="sourceline"><a href="index.org" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div id="outline-container-org821b10f" class="outline-2">
<h2 id="org821b10f">Introduction</h2>
<div class="outline-text-2" id="text-org821b10f">
<p>
The source data is some messy medical data. The goal is to extract dates from the data using <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>.
</p>
</div>
</div>

<div id="outline-container-org7662a05" class="outline-2">
<h2 id="org7662a05">Data Description</h2>
<div class="outline-text-2" id="text-org7662a05">
<p>
The data is in a file named <code>medical_records.csv</code>.
</p>

<ul class="org-ul">
<li>Each line of the <code>medical_records.csv</code> file corresponds to a medical note.</li>
<li>Each note has a date that needs to be extracted, but there is no single format for the dates.</li>
</ul>
<div class="highlight"><pre><span></span>class Messy:
    source = "medical_records.csv"
    def __init__(self):
	self._lines = None
	return

    @property
    def lines(self):
	"""Lines of medical notes

	Each line represents one medical none

	Returns:
	 list: list of medical notes
	"""
	if self._lines is None:
	    with open(self.source) as reader:
		self._lines = reader.readlines()
	return self._lines

    def __len__(self):
	"""the number of lines in the data"""
	return len(self.lines)

    def __getitem__(self, slicer):
	"""Return the line matching the slice

	Args:
	 slicer (slice): slice for the lines

	Raises:
	 IndexError: index out of range for the lines
	"""
	return self.lines[slicer]
</pre></div>

<pre class="example">
There are 500 notes in the messy medical data.

</pre>
</div>

<div id="outline-container-orgc4b57da" class="outline-3">
<h3 id="orgc4b57da">Sample Lines</h3>
<div class="outline-text-3" id="text-orgc4b57da">
<p>
Here are the first ten lines in the file.
</p>

<div class="highlight"><pre><span></span>for line in messy_data[:10]:
    print(line.strip())
</pre></div>

<p>
The goal of this assignment is to correctly identify all of the different date variants encoded in this dataset and to properly normalize and sort the dates. 
</p>

<p>
Here is a list of some of the variants you might encounter in this dataset.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-left">
</colgroup>
<thead><tr>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Examples</th>
</tr></thead>
<tbody>
<tr>
<td class="org-left">Month/Day/Year</td>
<td class="org-left">04/20/2009; 04/20/09; 4/20/09; 4/3/09</td>
</tr>
<tr>
<td class="org-left">Named Month Day Year</td>
<td class="org-left">Mar-20-2009; Mar 20, 2009; March 20, 2009;  Mar. 20, 2009; Mar 20 2009;</td>
</tr>
<tr>
<td class="org-left">Day Month Year</td>
<td class="org-left">20 Mar 2009; 20 March 2009; 20 Mar. 2009; 20 March, 2009</td>
</tr>
<tr>
<td class="org-left">Month Ordinal Day Year</td>
<td class="org-left">- Mar 20th, 2009; Mar 21st, 2009; Mar 22nd, 2009</td>
</tr>
<tr>
<td class="org-left">Named Month Year</td>
<td class="org-left">Feb 2009; Sep 2009; Oct 2010</td>
</tr>
<tr>
<td class="org-left">Month/Year</td>
<td class="org-left">6/2008; 12/2009</td>
</tr>
<tr>
<td class="org-left">Year</td>
<td class="org-left">2009; 2010</td>
</tr>
</tbody>
</table>
<p>
Once you have extracted these date patterns from the text, the next step is to sort them in ascending chronological order accoring to the following rules:
</p>

<ul class="org-ul">
<li>Assume all dates in xx/xx/xx format are mm/dd/yy</li>
<li>Assume all dates where year is encoded in only two digits are years from the 1900's (e.g. 1/5/89 is January 5th, 1989)</li>
<li>If the day is missing (e.g. 9/2009), assume it is the first day of the month (e.g. September 1, 2009).</li>
<li>If the month is missing (e.g. 2010), assume it is the first of January of that year (e.g. January 1, 2010).</li>
</ul>
<p>
With these rules in mind, find the correct date in each note and return a pandas Series in chronological order of the original Series' indices.
</p>

<p>
For example if the original series was this:
</p>

<pre class="example">
0    1999
1    2010
2    1978
3    2015
4    1985
</pre>

<pre class="example">
0    2
1    4
2    0
3    1
4    3
</pre>

<p>
Your score will be calculated using <a href="https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient">Kendall's tau</a>, a correlation measure for ordinal data.
</p>

<p>
<b>This function should return a Series of length 500 and dtype int.</b>
</p>
</div>
</div>
</div>
<div id="outline-container-org7bd9935" class="outline-2">
<h2 id="org7bd9935">Imports</h2>
<div class="outline-text-2" id="text-org7bd9935">
<div class="highlight"><pre><span></span># from pypi
import pandas
</pre></div>
</div>
</div>

<div id="outline-container-org47c5204" class="outline-2">
<h2 id="org47c5204">Loading The Data</h2>
<div class="outline-text-2" id="text-org47c5204">
<div class="highlight"><pre><span></span>with open('dates.txt') as reader:
    data = pandas.Series(reader.readlines())

data.head(10)
</pre></div>

<div class="highlight"><pre><span></span>data.describe()
</pre></div>
</div>
</div>

<div id="outline-container-org9fa8bba" class="outline-2">
<h2 id="org9fa8bba">The Grammar</h2>
<div class="outline-text-2" id="text-org9fa8bba">
</div>
<div id="outline-container-org6327fe9" class="outline-3">
<h3 id="org6327fe9">Cardinality</h3>
<div class="outline-text-3" id="text-org6327fe9">
<div class="highlight"><pre><span></span>ZERO_OR_MORE = '*'
ONE_OR_MORE = "+"
ZERO_OR_ONE = '?'
EXACTLY_TWO = "{2}"
ONE_OR_TWO = "{1,2}"
EXACTLY_ONE = '{1}'
</pre></div>
</div>
</div>

<div id="outline-container-orgc916af1" class="outline-3">
<h3 id="orgc916af1">Groups and Classes</h3>
<div class="outline-text-3" id="text-orgc916af1">
<div class="highlight"><pre><span></span>GROUP = r"({})"
NAMED = r"(?P&lt;{}&gt;{})"
CLASS = "[{}]"
NEGATIVE_LOOKAHEAD = "(?!{})"
NEGATIVE_LOOKBEHIND = "(?&lt;!{})"
POSITIVE_LOOKAHEAD = "(?={})"
POSITIVE_LOOKBEHIND = "(?&lt;={})"
ESCAPE = "\{}"
</pre></div>
</div>
</div>

<div id="outline-container-orgde683f2" class="outline-3">
<h3 id="orgde683f2">Numbers</h3>
<div class="outline-text-3" id="text-orgde683f2">
<div class="highlight"><pre><span></span>DIGIT = r"\d"
ONE_DIGIT  = DIGIT + EXACTLY_ONE
ONE_OR_TWO_DIGITS = DIGIT + ONE_OR_TWO
NON_DIGIT = NEGATIVE_LOOKAHEAD.format(DIGIT)
TWO_DIGITS = DIGIT + EXACTLY_TWO
THREE_DIGITS = DIGIT + "{3}"
EXACTLY_TWO_DIGITS = DIGIT + EXACTLY_TWO + NON_DIGIT
FOUR_DIGITS = DIGIT + r"{4}" + NON_DIGIT
</pre></div>
</div>
</div>

<div id="outline-container-orgfe55086" class="outline-3">
<h3 id="orgfe55086">String Literals</h3>
<div class="outline-text-3" id="text-orgfe55086">
<div class="highlight"><pre><span></span>SLASH = r"/"
OR = r'|'
LOWER_CASE = "a-z"
SPACE = "\s"
DOT = "."
DASH = "-"
COMMA = ","
PUNCTUATION = CLASS.format(DOT + COMMA + DASH)
EMPTY_STRING = ""
</pre></div>
</div>
</div>

<div id="outline-container-org917be4d" class="outline-3">
<h3 id="org917be4d">Dates</h3>
<div class="outline-text-3" id="text-org917be4d">
<p>
These are parts to build up the date-expressions.
</p>
<div class="highlight"><pre><span></span>MONTH_SUFFIX = (CLASS.format(LOWER_CASE) + ZERO_OR_MORE
		+ CLASS.format(SPACE + DOT + COMMA + DASH) + ONE_OR_TWO)
MONTH_PREFIXES = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split()
MONTHS = [month + MONTH_SUFFIX for month in MONTH_PREFIXES]
MONTHS = GROUP.format(OR.join(MONTHS))
DAY_SUFFIX = CLASS.format(DASH + COMMA + SPACE) + ONE_OR_TWO
DAYS = ONE_OR_TWO_DIGITS + DAY_SUFFIX
YEAR = FOUR_DIGITS
</pre></div>

<p>
This is for dates like <i>Mar 21st, 2009</i>, those with suffixes on the days.
</p>
<div class="highlight"><pre><span></span>CONTRACTED = (ONE_OR_TWO_DIGITS
	      + LOWER_CASE
	      + EXACTLY_TWO
	      )
CONTRACTION = NAMED.format("contraction",
			   MONTHS
			   + CONTRACTED
			   + DAY_SUFFIX
			   + YEAR)
</pre></div>

<p>
This is for dates that have no days in them, like <i>May 2009</i>.
</p>
<div class="highlight"><pre><span></span>NO_DAY_BEHIND = NEGATIVE_LOOKBEHIND.format(DIGIT + SPACE)
NO_DAY = NAMED.format("no_day", NO_DAY_BEHIND + MONTHS + YEAR)
</pre></div>

<p>
This is for the most common form (that I use) - <i>May 21, 2017</i>.
</p>
<div class="highlight"><pre><span></span>WORDS = NAMED.format("words", MONTHS + DAYS + YEAR)
</pre></div>

<p>
This is for the case where the day is placed before them month - <i>20 March, 2009</i>.
</p>
<div class="highlight"><pre><span></span>BACKWARDS = NAMED.format("backwards", ONE_OR_TWO_DIGITS + SPACE + MONTHS + YEAR)
</pre></div>

<p>
This is the case where slashes are used but only two digits were used for the year (so we're assuming it's in the twentieth century) - <i>8/4/98</i>.
</p>
<div class="highlight"><pre><span></span>slashed = SLASH.join([ONE_OR_TWO_DIGITS,
		      ONE_OR_TWO_DIGITS,
		      EXACTLY_TWO_DIGITS])
dashed = DASH.join([ONE_OR_TWO_DIGITS,
		    ONE_OR_TWO_DIGITS,
		    EXACTLY_TWO_DIGITS])
TWENTIETH_CENTURY = NAMED.format("twentieth",
				 OR.join([slashed, dashed]))
</pre></div>

<p>
This is the case where digits with slashes are used and all four digits are used for the year - <i>8/4/1998</i>.
</p>
<div class="highlight"><pre><span></span>NUMERIC = NAMED.format("numeric",
		       SLASH.join([ONE_OR_TWO_DIGITS,
				   ONE_OR_TWO_DIGITS,
				   FOUR_DIGITS]))
</pre></div>

<p>
This is the case where only month and year are given as digits - <i>9/2009</i>. There are two expressions, because the day can be one or two digits.
</p>

<div class="highlight"><pre><span></span>NO_PRECEDING_SLASH = NEGATIVE_LOOKBEHIND.format(SLASH)
NO_PRECEDING_SLASH_DIGIT = NEGATIVE_LOOKBEHIND.format(CLASS.format(SLASH + DIGIT))
NO_ONE_DAY = (NO_PRECEDING_SLASH_DIGIT
	      + ONE_DIGIT
	      + SLASH
	      + FOUR_DIGITS)
NO_TWO_DAYS = (NO_PRECEDING_SLASH
	       + TWO_DIGITS
	       + SLASH
	       + FOUR_DIGITS)
NO_DAY_NUMERIC = NAMED.format("no_day_numeric",
			      NO_ONE_DAY
			      + OR
			      + NO_TWO_DAYS
			      )
</pre></div>

<p>
This is the case where only a year was given. This is the hardest case, since you don't want to accidentally match the other cases, but the text preceding and following it could be anything. For the look-behind, all the cases have to have the same number of characters so we can't re-use the other expressions
</p>

<div class="highlight"><pre><span></span>CENTURY = GROUP.format('19' + OR + "20") + TWO_DIGITS
DIGIT_SLASH = DIGIT + SLASH
DIGIT_DASH = DIGIT + DASH
DIGIT_SPACE = DIGIT + SPACE
LETTER_SPACE = CLASS.format(LOWER_CASE) + SPACE
COMMA_SPACE = COMMA + SPACE
YEAR_PREFIX = NEGATIVE_LOOKBEHIND.format(OR.join([
    DIGIT_SLASH,
    DIGIT_DASH,
    DIGIT_SPACE,
    LETTER_SPACE,
    COMMA_SPACE,    
]))

YEAR_ONLY = NAMED.format("year_only",
			 YEAR_PREFIX + CENTURY
)
</pre></div>

<p>
These are leftovers that don't really match anything.
</p>

<div class="highlight"><pre><span></span>IN_PREFIX = POSITIVE_LOOKBEHIND.format(CLASS.format('iI') + 'n' + SPACE) + CENTURY
SINCE_PREFIX = POSITIVE_LOOKBEHIND.format(CLASS.format("Ss") + 'ince' + SPACE) + CENTURY
AGE = POSITIVE_LOOKBEHIND.format("Age" + SPACE + TWO_DIGITS + COMMA + SPACE) + CENTURY
AGE_COMMA = POSITIVE_LOOKBEHIND.format("Age" + COMMA + SPACE + TWO_DIGITS + COMMA + SPACE) + CENTURY
OTHERS = ['delivery', "quit", "attempt", "nephrectomy", THREE_DIGITS]
OTHERS = [POSITIVE_LOOKBEHIND.format(label + SPACE) + CENTURY for label in OTHERS]
OTHERS = OR.join(OTHERS)
LEFTOVERS_PREFIX = OR.join([IN_PREFIX, SINCE_PREFIX, AGE, AGE_COMMA]) + OR + OTHERS
LEFTOVERS = NAMED.format("leftovers", LEFTOVERS_PREFIX)
</pre></div>

<p>
This is the combined expression for all the dates - the one that should be used to extract them from the data.
</p>
<div class="highlight"><pre><span></span>DATE = NAMED.format("date", OR.join([NUMERIC,
				     TWENTIETH_CENTURY,
				     WORDS,
				     BACKWARDS,
				     CONTRACTION,
				     NO_DAY,
				     NO_DAY_NUMERIC,
				     YEAR_ONLY,
				     LEFTOVERS]))
</pre></div>

<div class="highlight"><pre><span></span>def twentieth_century(date):
    """adds a 19 to the year

    Args:
     date (re.Regex): Extracted date
    """
    month, day, year = date.group(1).split(SLASH)
    year = "19{}".format(year)
    return SLASH.join([month, day, year])
</pre></div>

<div class="highlight"><pre><span></span>def take_two(line):
    match = re.search(TWENTIETH_CENTURY, line)
    if match:
	return twentieth_century(match)
    return line
</pre></div>
</div>
</div>
</div>

<div id="outline-container-orgc97004a" class="outline-2">
<h2 id="orgc97004a">Applying The Grammer</h2>
<div class="outline-text-2" id="text-orgc97004a">
<div class="highlight"><pre><span></span>def extract_and_count(expression, data, name):
    """extract all matches and report the count

    Args:
     expression (str): regular expression to match
     data (pandas.Series): data with dates to extratc
     name (str): name of the group for the expression

    Returns:
     tuple (pandas.Series, int): extracted dates, count
    """
    extracted = data.str.extractall(expression)[name]
    count = len(extracted)
    print("'{}' matched {} rows".format(name, count))
    return extracted, count
</pre></div>

<div class="highlight"><pre><span></span>numeric, numeric_count = extract_and_count(NUMERIC, data, 'numeric')
</pre></div>

<div class="highlight"><pre><span></span>twentieth, twentieth_count = extract_and_count(TWENTIETH_CENTURY, data, 'twentieth')
</pre></div>

<div class="highlight"><pre><span></span>words, words_count = extract_and_count(WORDS, data, 'words')
</pre></div>

<div class="highlight"><pre><span></span>backwards, backwards_count = extract_and_count(BACKWARDS, data, 'backwards')
</pre></div>

<div class="highlight"><pre><span></span>contraction_data, contraction = extract_and_count(CONTRACTION, data, 'contraction')
</pre></div>

<div class="highlight"><pre><span></span>no_day, no_day_count = extract_and_count(NO_DAY, data, 'no_day')
</pre></div>

<div class="highlight"><pre><span></span>no_day_numeric, no_day_numeric_count = extract_and_count(NO_DAY_NUMERIC, data,
							 "no_day_numeric")
</pre></div>

<div class="highlight"><pre><span></span>year_only, year_only_count = extract_and_count(YEAR_ONLY, data, "year_only")
</pre></div>

<div class="highlight"><pre><span></span>leftovers, leftovers_count = extract_and_count(LEFTOVERS, data, "leftovers")
</pre></div>

<div class="highlight"><pre><span></span>found = data.str.extractall(DATE)
total_found = len(found.date)

print("Total Found: {}".format(total_found))
print("Remaining: {}".format(len(data) - total_found))
print("Discrepancy: {}".format(total_found - (numeric_count
					      + twentieth_count
					      + words_count
					      + backwards_count
					      + contraction
					      + no_day_count
					      + no_day_numeric_count
					      + year_only_count
					      + leftovers_count)))
</pre></div>

<div class="highlight"><pre><span></span>missing = [label for label in data.index if label not in found.index.levels[0]]
try:
    print(missing[0], data.loc[missing[0]])
except IndexError:
    print("all rows matched")
</pre></div>
</div>
</div>

<div id="outline-container-org216bb42" class="outline-2">
<h2 id="org216bb42">Unifying the Formats</h2>
<div class="outline-text-2" id="text-org216bb42">
<p>
To make it simpler, I'm going to use the <code>mm/dd/yyyy</code> format for the dates. I'm going to use the extracted series to avoid having different clean-up cases contaminating each other - e.g. dealing with 'January' when the day comes first as opposed to when the month comes first.
</p>
</div>
<div id="outline-container-orgfe38709" class="outline-3">
<h3 id="orgfe38709">Helper Functions</h3>
<div class="outline-text-3" id="text-orgfe38709">
</div>
<div id="outline-container-orgf0fe88b" class="outline-4">
<h4 id="orgf0fe88b">Clean</h4>
<div class="outline-text-4" id="text-orgf0fe88b">
<p>
This is a generic function to clean up some data. I was initially using it directly, but for cases where the expression and replacement function are used more than once, there are helper functions to make it easier.
</p>

<div class="highlight"><pre><span></span>def clean(source, expression, replacement, sample=5):
    """applies the replacement to the source

    as a side-effect shows sample rows before and after

    Args:
     source (pandas.Series): source of the strings
     expression (str): regular expression to match what to replace
     replacement: function or expression to replace the matching expression
     sample (int): number of randomly chosen examples to show

    Returns:
     pandas.Series: the source with the replacement applied to it
    """
    print("Random Sample Before:")
    print(source.sample(sample))
    cleaned = source.str.replace(expression, replacement)
    print("\nRandom Sample After:")
    print(cleaned.sample(sample))
    print("\nCount of cleaned: {}".format(len(cleaned)))
    assert len(source) == len(cleaned)
    return cleaned
</pre></div>
</div>
</div>

<div id="outline-container-org4a2073d" class="outline-4">
<h4 id="org4a2073d">Clean Punctuation</h4>
<div class="outline-text-4" id="text-org4a2073d">
<div class="highlight"><pre><span></span>def clean_punctuation(source, sample=5):
    """removes punctuation

    Args:
     source (pandas.Series): data to clean
     sample (int): size of sample to show

    Returns:
     pandas.Series: source with punctuation removed
    """
    print("Cleaning Punctuation")
    if any(source.str.contains(PUNCTUATION)):
	source = clean(source, PUNCTUATION, EMPTY_STRING)
    return source
</pre></div>
</div>
</div>
<div id="outline-container-org380e083" class="outline-4">
<h4 id="org380e083">Convert Long Month Names to Three-Letter Names</h4>
<div class="outline-text-4" id="text-org380e083">
<div class="highlight"><pre><span></span>LONG_TO_SHORT = dict(January="Jan",
		     February="Feb",
		     March="Mar",
		     April="Apr",
		     May="May",
		     June="Jun",
		     July="Jul",
		     August="Aug",
		     September="Sep",
		     October="Oct",
		     November="Nov",
		     December="Dec")

# it turns out there are spelling errors in the data so this has to be fuzzy
LONG_TO_SHORT_EXPRESSION = OR.join([GROUP.format(month)
				    + CLASS.format(LOWER_CASE)
				    + ZERO_OR_MORE
				    for month in LONG_TO_SHORT.values()])

def long_month_to_short(match):
    """convert long month to short

    Args:
     match (re.Match): object matching a long month

    Returns:
     str: shortened version of the month
    """
    return match.group(match.lastindex)
</pre></div>

<p>
This next function is the one you would actually use to make the conversion.
</p>

<div class="highlight"><pre><span></span>def convert_long_months_to_short(source, sample=5):
    """convert long month names to short

    Args:
     source (pandas.Series): data with months
     sample (int): size of sample to show

    Returns:
     pandas.Series: data with short months
    """
    return clean(source,
		 LONG_TO_SHORT_EXPRESSION,
		 long_month_to_short)
</pre></div>
</div>
</div>
<div id="outline-container-org3e02ce1" class="outline-4">
<h4 id="org3e02ce1">Add January 1 to year-only dates</h4>
<div class="outline-text-4" id="text-org3e02ce1">
<div class="highlight"><pre><span></span>def add_month_date(match):
    """adds 01/01 to years

    Args:
     match (re.Match): object that only matched a 4-digit year

    Returns:
     str: 01/01/YYYY
    """
    return "01/01/" + match.group()
</pre></div>

<p>
And now the function to actually call.
</p>

<div class="highlight"><pre><span></span>def add_january_one(source):
    """adds /01/01/ to year-only dates

    Args:
     source (pandas.Series): data with the dates

    Returns:
     pandas.Series: years in source with /01/01/ added
    """
    return clean(source, YEAR_ONLY, add_month_date)
</pre></div>
</div>
</div>
<div id="outline-container-org97c4d67" class="outline-4">
<h4 id="org97c4d67">Two-Digit Numbers</h4>
<div class="outline-text-4" id="text-org97c4d67">
<p>
This makes sure that there are exactly two digits in a number, adding a leading zero if needed.
</p>
<div class="highlight"><pre><span></span>two_digit_expression = GROUP.format(ONE_OR_TWO_DIGITS) + POSITIVE_LOOKAHEAD.format(SLASH)

def two_digits(match):
    """add a leading zero if needed

    Args:
     match (re.Match): match with one or two digits

    Returns:
     str: the matched string with leading zero if needed
    """
    # for some reason the string-formatting raises an error if it's a string
    # so cast it to an int
    return "{:02}".format(int(match.group()))
</pre></div>

<p>
This is the function to call for the case where the number is followed by a slash (e.g. <code>2/</code>).
</p>

<div class="highlight"><pre><span></span>def clean_two_digits(source, sample=5):
    """makes sure source has two-digits

    Args:
     source (pandas.Series): data with digit followed by slash
     sample (int): number of samples to show

    Returns:
     pandas.Series: source with digits coerced to two digits
    """
    return clean(source, two_digit_expression, two_digits, sample)
</pre></div>

<p>
This is like <code>clean_two_digits</code> but it doesn't check for the trailing slash. Use this if you have an isolated column of numbers that need to be two-digits.
</p>

<div class="highlight"><pre><span></span>def clean_two_digits_isolated(source, sample=5):
    """cleans two digits that are standalone

    Args:
     source (pandas.Series): source of the data
     sample (int): number of samples to show

    Returns:
     pandas.Series: converted data
    """
    return clean(source, ONE_OR_TWO_DIGITS, two_digits, sample)
</pre></div>
</div>
</div>

<div id="outline-container-org7f174fa" class="outline-4">
<h4 id="org7f174fa">Cleaning Up Months</h4>
<div class="outline-text-4" id="text-org7f174fa">
<p>
These clean up and convert written months (e.g. change <code>Aug</code> to <code>08</code>).
</p>

<div class="highlight"><pre><span></span>digits = ("{:02}".format(month) for month in range(1, 13))
MONTH_TO_DIGITS = dict(zip(MONTH_PREFIXES, digits))
SHORT_MONTHS_EXPRESSION = OR.join((GROUP.format(month) for month in MONTH_TO_DIGITS))
def month_to_digits(match):
    """converts short month to digits

    Args:
     match (re.Match): object with short-month

    Returns:
     str: month as two-digit number (e.g. Jan -&gt; 01)
    """
    return MONTH_TO_DIGITS[match.group()]
</pre></div>

<div class="highlight"><pre><span></span>def convert_short_month_to_digits(source, sample=5):
    """converts three-letter months to two-digits

    Args:
     source (pandas.Series): data with three-letter months
     sample (int): number of samples to show

    Returns:
     pandas.Series: source with short-months coverted to digits
    """
    return clean(source,
		 SHORT_MONTHS_EXPRESSION,
		 month_to_digits,
		 sample)
</pre></div>

<p>
This function runs the previous three and is the main one that should be used. The others can be run individually for troubleshooting, though.
</p>
<div class="highlight"><pre><span></span>def clean_months(source, sample=5):
    """clean up months (which start as words)

    Args:
     source (pandas.Series): source of the months
     sample (int): number of random samples to show
    """
    cleaned = clean_punctuation(source)

    print("Converting long months to short")
    cleaned = clean(cleaned,
		    LONG_TO_SHORT_EXPRESSION,
		    long_month_to_short, sample)

    print("Converting short months to digits")
    cleaned = clean(cleaned,
		    SHORT_MONTHS_EXPRESSION,
		    month_to_digits, sample)
    return cleaned
</pre></div>
</div>
</div>
<div id="outline-container-orgacc9b49" class="outline-4">
<h4 id="orgacc9b49">Frame To Series</h4>
<div class="outline-text-4" id="text-orgacc9b49">
<p>
This is for the case where the date-fields were broken up into columns in a data-frame.
</p>
<div class="highlight"><pre><span></span>def frame_to_series(frame, index_source, samples=5):
    """re-combines data-frame into a series

    Args:
     frame (pandas.DataFrame): frame with month, day, year columns
     index_source (pandas.series): source to copy index from
     samples (index): number of random entries to print when done

    Returns:
     pandas.Series: series with dates as month/day/year
    """
    combined = frame.month + SLASH + frame.day + SLASH + frame.year
    combined.index = index_source.index
    print(combined.sample(samples))
    return combined
</pre></div>
</div>
</div>
</div>

<div id="outline-container-orgf7ebd56" class="outline-3">
<h3 id="orgf7ebd56">Year Only</h3>
<div class="outline-text-3" id="text-orgf7ebd56">
<p>
For the case where there is only a year, I'll add January 1 to the dates.
</p>

<div class="highlight"><pre><span></span>year_only_cleaned = add_january_one(year_only)
</pre></div>
</div>
</div>

<div id="outline-container-org02b633d" class="outline-3">
<h3 id="org02b633d">Leftovers</h3>
<div class="outline-text-3" id="text-org02b633d">
<p>
These were the odd cases that didn't seem to have a real pattern. Since I used a negative lookbehind they only have the years in them, like the other year-only cases.
</p>

<div class="highlight"><pre><span></span>leftovers_cleaned = add_january_one(leftovers)
</pre></div>

<div class="highlight"><pre><span></span>cleaned = pandas.concat([year_only_cleaned, leftovers_cleaned])
print(len(cleaned))
</pre></div>
</div>
</div>

<div id="outline-container-orgb42461b" class="outline-3">
<h3 id="orgb42461b">No Day Numeric</h3>
<div class="outline-text-3" id="text-orgb42461b">
<p>
This is for the case where the date is formatted with slashes and there are no day-values. To make the months uniform I'm going to make them all two-digits first.
</p>

<div class="highlight"><pre><span></span>no_day_numeric_cleaned = clean_two_digits(no_day_numeric)
</pre></div>

<p>
Now I'll add the day.
</p>

<div class="highlight"><pre><span></span>no_day_numeric_cleaned = clean(no_day_numeric_cleaned,
			       SLASH,
			       lambda m: "/01/")
</pre></div>

<p>
And add it to the total.
</p>

<div class="highlight"><pre><span></span>original = len(cleaned)
cleaned = pandas.concat([cleaned, no_day_numeric_cleaned])
assert len(cleaned) == no_day_numeric_count + original
</pre></div>

<div class="highlight"><pre><span></span>print(len(cleaned))
</pre></div>
</div>
</div>

<div id="outline-container-orgecf8023" class="outline-3">
<h3 id="orgecf8023">No Day</h3>
<div class="outline-text-3" id="text-orgecf8023">
<p>
This is for cases like <i>Mar 2011</i> where no day was given. We're going to assume that it's the first day of the month for each case.
</p>

<div class="highlight"><pre><span></span>no_day_cleaned = clean_months(no_day)
</pre></div>

<p>
Now we need to replace the spaces with the days.
</p>

<div class="highlight"><pre><span></span>no_day_cleaned = clean(no_day_cleaned,
		       SPACE + ONE_OR_MORE,
		       lambda match: "/01/")
</pre></div>

<p>
Now we can add it to the cleaned.
</p>

<div class="highlight"><pre><span></span>original = len(cleaned)
cleaned = pandas.concat([cleaned, no_day_cleaned])
print(len(cleaned))
</pre></div>

<p>
Now to make sure we're where we expect we are.
</p>

<div class="highlight"><pre><span></span>assert len(cleaned) == no_day_count + original
</pre></div>
</div>
</div>

<div id="outline-container-orgcf61f39" class="outline-3">
<h3 id="orgcf61f39">Contraction</h3>
<div class="outline-text-3" id="text-orgcf61f39">
<p>
There were no matches for the contraction so I'll ignore it for now. 
</p>
</div>
</div>
<div id="outline-container-org75f6d2a" class="outline-3">
<h3 id="org75f6d2a">Backwards</h3>
<div class="outline-text-3" id="text-org75f6d2a">
<p>
This is the case where the day comes first. The first thing I'll do is split them up.
</p>

<div class="highlight"><pre><span></span>frame = pandas.DataFrame(backwards.str.split().tolist(),
			 columns="day month year".split())
frame.head()
</pre></div>

<p>
The next thing to do is to make sure the days all have two digits.
</p>

<div class="highlight"><pre><span></span>frame.day = clean_two_digits(frame.day)
</pre></div>

<p>
Next comes the months. This is basically the same problem as with the <i>no day</i> case so I'll re-use some of the code for that.
</p>


<div class="highlight"><pre><span></span>frame.month = clean_months(frame.month)
</pre></div>

<p>
Now we need to combine them back together. In hindsight it might have been easier to convert everything into data frames instead of the other way around. Or maybe not. Since we want the indexes from the original data as our final answer I also have to copy the index from the original series
</p>

<div class="highlight"><pre><span></span>backwards_cleaned = frame_to_series(frame, backwards)
</pre></div>

<pre class="example">
140  0        02/14/1995
177  0        01/18/1990
156  0        05/26/1974
189  0        10/21/1977
160  0        10/21/2007
dtype: object

</pre>

<p>
No it gets added to the combined series.
</p>

<div class="highlight"><pre><span></span>original = len(cleaned)
cleaned = pandas.concat([cleaned, backwards_cleaned])
assert len(cleaned) == original + backwards_count
</pre></div>

<div class="highlight"><pre><span></span>print(len(cleaned))
</pre></div>
</div>
</div>

<div id="outline-container-org4aef5f4" class="outline-3">
<h3 id="org4aef5f4">Words</h3>
<div class="outline-text-3" id="text-org4aef5f4">
<p>
Since working with the data frame was easier than I though it would be I'll do that again.
</p>

<div class="highlight"><pre><span></span>frame = pandas.DataFrame(words.str.split().tolist(), columns="month day year".split())
print(frame.head())
</pre></div>

<p>
First we'll clean out the months.
</p>

<div class="highlight"><pre><span></span>frame.month = clean_months(frame.month)
</pre></div>

<p>
Now we'll clean up the punctuation for the days.
</p>

<div class="highlight"><pre><span></span>frame.day = clean_punctuation(frame.day)
</pre></div>

<p>
So, what do we have so far?
</p>

<div class="highlight"><pre><span></span>frame.head()
</pre></div>

<p>
At this point we need to combine everything with a slash and restore the index.
</p>

<div class="highlight"><pre><span></span>words_cleaned = frame_to_series(frame, words)
</pre></div>

<p>
Now we'll add it to the total.
</p>

<div class="highlight"><pre><span></span>original = len(cleaned)
cleaned = pandas.concat([cleaned, words_cleaned])
assert len(cleaned) == original + words_count
print(len(cleaned))
</pre></div>
</div>
</div>

<div id="outline-container-org43786f1" class="outline-3">
<h3 id="org43786f1">Twentieth Century</h3>
<div class="outline-text-3" id="text-org43786f1">
<p>
We'll do the same trick with creating a dataframe. The first thing, though, is to replace the dashes with slashes.
</p>

<div class="highlight"><pre><span></span>print(twentieth.iloc[21])
twentieth_cleaned = twentieth.str.replace(DASH, SLASH)
print(cleaned.iloc[21])
</pre></div>

<p>
Now, we'll create the frame.
</p>

<div class="highlight"><pre><span></span>frame = pandas.DataFrame(twentieth_cleaned.str.split(SLASH).tolist(),
			 columns=["month", "day", "year"])
print(frame.head())
</pre></div>
</div>

<div id="outline-container-org53eeea7" class="outline-4">
<h4 id="org53eeea7">Months</h4>
<div class="outline-text-4" id="text-org53eeea7">
<p>
The months need to be converted to two-digits.
</p>

<div class="highlight"><pre><span></span>frame.month = clean_two_digits_isolated(frame.month)
</pre></div>

<p>
As do the days.
</p>

<div class="highlight"><pre><span></span>frame.day = clean_two_digits_isolated(frame.day)
</pre></div>

<div class="highlight"><pre><span></span>frame.head()
</pre></div>

<p>
Now we have to add <code>19</code> to each of the years.
</p>

<div class="highlight"><pre><span></span>frame.year = clean(frame.year, TWO_DIGITS, lambda match: "19" + match.group())
</pre></div>

<p>
Now we have to join them back up.
</p>

<div class="highlight"><pre><span></span>twentieth_cleaned = frame_to_series(frame, twentieth)
</pre></div>

<div class="highlight"><pre><span></span>original = len(cleaned)
cleaned = pandas.concat([cleaned, twentieth_cleaned])
</pre></div>

<div class="highlight"><pre><span></span>assert len(cleaned) == original + twentieth_count
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org6654bd8" class="outline-3">
<h3 id="org6654bd8">Numeric</h3>
<div class="outline-text-3" id="text-org6654bd8">
<p>
The final category is dates with the format <code>mm/dd/yyyy</code>.
</p>

<div class="highlight"><pre><span></span>print(numeric.head())
</pre></div>

<p>
We should check and make sure there are no dashes here.
</p>

<div class="highlight"><pre><span></span>has_dashes = numeric.str.contains(DASH)
print(numeric[has_dashes])
</pre></div>

<p>
It looks like it doesn't so we'll skip this check.
</p>

<div class="highlight"><pre><span></span>frame = pandas.DataFrame(numeric.str.split(SLASH).tolist(),
			 columns="month day year".split())
print(frame.head())
</pre></div>

<div class="highlight"><pre><span></span>frame.month = clean_two_digits_isolated(frame.month)
</pre></div>

<div class="highlight"><pre><span></span>frame.day = clean_two_digits_isolated(frame.day)
</pre></div>

<div class="highlight"><pre><span></span>numeric_cleaned = frame_to_series(frame, numeric)
</pre></div>

<div class="highlight"><pre><span></span>original = len(cleaned)
cleaned = pandas.concat([cleaned, numeric_cleaned])
assert len(cleaned) == original + numeric_count
print(len(cleaned))
</pre></div>

<p>
At this point it looks like we've cleaned all the cases.
</p>
</div>
</div>

<div id="outline-container-orgf9cf72f" class="outline-3">
<h3 id="orgf9cf72f">Re-combining The Cleaned</h3>
<div class="outline-text-3" id="text-orgf9cf72f">
<p>
Because these notebooks can execute things out of order I'm going to create one monolithic concatenation and ignore the one that I was using to keep the running total.
</p>

<div class="highlight"><pre><span></span>cleaned = pandas.concat([numeric_cleaned,
			 twentieth_cleaned,
			 words_cleaned,
			 backwards_cleaned,
			 no_day_cleaned,
			 no_day_numeric_cleaned,
			 year_only_cleaned,
			 leftovers_cleaned,
])
print(len(cleaned))
print(cleaned.head())
assert len(cleaned) == len(data)
</pre></div>
</div>
</div>
</div>

<div id="outline-container-orgb33d9b5" class="outline-2">
<h2 id="orgb33d9b5">Convert to Datetimes</h2>
<div class="outline-text-2" id="text-orgb33d9b5">
<div class="highlight"><pre><span></span>print(cleaned.head())
datetimes = pandas.to_datetime(cleaned, format="%m/%d/%Y")
print(datetimes.head())
</pre></div>

<div class="highlight"><pre><span></span>sorted_dates = datetimes.sort_values()
print(sorted_dates.head())
</pre></div>

<div class="highlight"><pre><span></span>print(sorted_dates.tail())
</pre></div>

<p>
The grader wants a Series with the indices of the original data put in the order of the sorted dates.
</p>

<div class="highlight"><pre><span></span>answer = pandas.Series(sorted_dates.index.labels[0])
print(answer.head())
</pre></div>
</div>
</div>

<div id="outline-container-orgfb645ce" class="outline-2">
<h2 id="orgfb645ce">The date<sub>sorter</sub> Function</h2>
<div class="outline-text-2" id="text-orgfb645ce">
<p>
This is the function called by the grader. Since the work was done outside of it we just need to make sure that it returns our answer.
</p>

<div class="highlight"><pre><span></span>def date_sorter():
    return answer
</pre></div>

<p>
<b>note:</b> This produced a 94% score, so there are still some cases not correctly handled.
</p>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/textprocessing-datacleaning/" rel="tag">textprocessing datacleaning</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../international-olympiad-in-informatics/" rel="prev" title="International Olympiad in Informatics">Previous post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2018         <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
