#+TITLE: Messy Medical Data

* Introduction
Our source data is some messy medical data and we will use regular expressions to extract relevant information from it.

 - Each line of the =dates.txt= file corresponds to a medical note. 
 - Each note has a date that needs to be extracted, but each date is encoded in one of many formats.

The goal of this assignment is to correctly identify all of the different date variants encoded in this dataset and to properly normalize and sort the dates. 

Here is a list of some of the variants you might encounter in this dataset:

 - 04/20/2009; 04/20/09; 4/20/09; 4/3/09
 - Mar-20-2009; Mar 20, 2009; March 20, 2009;  Mar. 20, 2009; Mar 20 2009;
 - 20 Mar 2009; 20 March 2009; 20 Mar. 2009; 20 March, 2009
 - Mar 20th, 2009; Mar 21st, 2009; Mar 22nd, 2009
 - Feb 2009; Sep 2009; Oct 2010
 - 6/2008; 12/2009
 - 2009; 2010
 
Once you have extracted these date patterns from the text, the next step is to sort them in ascending chronological order accoring to the following rules:

 -  Assume all dates in xx/xx/xx format are mm/dd/yy
 -  Assume all dates where year is encoded in only two digits are years from the 1900's (e.g. 1/5/89 is January 5th, 1989)
 -  If the day is missing (e.g. 9/2009), assume it is the first day of the month (e.g. September 1, 2009).
 -  If the month is missing (e.g. 2010), assume it is the first of January of that year (e.g. January 1, 2010).

With these rules in mind, find the correct date in each note and return a pandas Series in chronological order of the original Series' indices.
 
For example if the original series was this:

#+BEGIN_EXAMPLE
     0    1999
     1    2010
     2    1978
     3    2015
     4    1985
#+END_EXAMPLE

# Your function should return this:

#+BEGIN_EXAMPLE
     0    2
     1    4
     2    0
     3    1
     4    3
#+END_EXAMPLE

Your score will be calculated using [[https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient][Kendall's tau]], a correlation measure for ordinal data.
 
*This function should return a Series of length 500 and dtype int.*
* Imports
#+BEGIN_SRC ipython :session assignment1 :results none
# from pypi
import pandas
#+END_SRC

* Loading The Data

#+BEGIN_SRC ipython :session assignment1
with open('dates.txt') as reader:
    data = pandas.Series(reader.readlines())

data.head(10)
#+END_SRC

#+RESULTS:
#+begin_example
0         03/25/93 Total time of visit (in minutes):\n
1                       6/18/85 Primary Care Doctor:\n
2    sshe plans to move as of 7/8/71 In-Home Servic...
3                7 on 9/27/75 Audit C Score Current:\n
4    2/6/96 sleep studyPain Treatment Pain Level (N...
5                    .Per 7/06/79 Movement D/O note:\n
6    4, 5/18/78 Patient's thoughts about current su...
7    10/24/89 CPT Code: 90801 - Psychiatric Diagnos...
8                         3/7/86 SOS-10 Total Score:\n
9             (4/10/71)Score-1Audit C Score Current:\n
dtype: object
#+end_example

#+BEGIN_SRC ipython :session assignment1
data.describe()
#+END_SRC

#+RESULTS:
: count                                                   500
: unique                                                  500
: top       7-29-75 CPT Code: 90801 - Psychiatric Diagnosi...
: freq                                                      1
: dtype: object

* The Grammar
** Cardinality
#+BEGIN_SRC ipython :session assignment1 :results none
ZERO_OR_MORE = '*'
ONE_OR_MORE = "+"
ZERO_OR_ONE = '?'
EXACTLY_TWO = "{2}"
ONE_OR_TWO = "{1,2}"
EXACTLY_ONE = '{1}'
#+END_SRC

** Groups and Classes
#+BEGIN_SRC ipython :session assignment1 :results none
GROUP = r"({})"
NAMED = r"(?P<{}>{})"
CLASS = "[{}]"
NEGATIVE_LOOKAHEAD = "(?!{})"
NEGATIVE_LOOKBEHIND = "(?<!{})"
POSITIVE_LOOKAHEAD = "(?={})"
POSITIVE_LOOKBEHIND = "(?<={})"
ESCAPE = "\{}"
#+END_SRC

** Numbers
#+BEGIN_SRC ipython :session assignment1 :results none
DIGIT = r"\d"
ONE_DIGIT  = DIGIT + EXACTLY_ONE
ONE_OR_TWO_DIGITS = DIGIT + ONE_OR_TWO
NON_DIGIT = NEGATIVE_LOOKAHEAD.format(DIGIT)
TWO_DIGITS = DIGIT + EXACTLY_TWO
THREE_DIGITS = DIGIT + "{3}"
EXACTLY_TWO_DIGITS = DIGIT + EXACTLY_TWO + NON_DIGIT
FOUR_DIGITS = DIGIT + r"{4}" + NON_DIGIT
#+END_SRC

** String Literals
#+BEGIN_SRC ipython :session assignment1 :results none
SLASH = r"/"
OR = r'|'
LOWER_CASE = "a-z"
SPACE = "\s"
DOT = "."
DASH = "-"
COMMA = ","
PUNCTUATION = CLASS.format(DOT + COMMA + DASH)
EMPTY_STRING = ""
#+END_SRC

** Dates
   These are parts to build up the date-expressions.
#+BEGIN_SRC ipython :session assignment1 :results none
MONTH_SUFFIX = (CLASS.format(LOWER_CASE) + ZERO_OR_MORE
                + CLASS.format(SPACE + DOT + COMMA + DASH) + ONE_OR_TWO)
MONTH_PREFIXES = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split()
MONTHS = [month + MONTH_SUFFIX for month in MONTH_PREFIXES]
MONTHS = GROUP.format(OR.join(MONTHS))
DAY_SUFFIX = CLASS.format(DASH + COMMA + SPACE) + ONE_OR_TWO
DAYS = ONE_OR_TWO_DIGITS + DAY_SUFFIX
YEAR = FOUR_DIGITS
#+END_SRC

This is for dates like /Mar 21st, 2009/, those with suffixes on the days.
#+BEGIN_SRC ipython :session assignment1 :results none
CONTRACTED = (ONE_OR_TWO_DIGITS
              + LOWER_CASE
              + EXACTLY_TWO
              )
CONTRACTION = NAMED.format("contraction",
                           MONTHS
                           + CONTRACTED
                           + DAY_SUFFIX
                           + YEAR)
#+END_SRC

This is for dates that have no days in them, like /May 2009/.
#+BEGIN_SRC ipython :session assignment1 :results none
NO_DAY_BEHIND = NEGATIVE_LOOKBEHIND.format(DIGIT + SPACE)
NO_DAY = NAMED.format("no_day", NO_DAY_BEHIND + MONTHS + YEAR)
#+END_SRC

This is for the most common form (that I use) - /May 21, 2017/.
#+BEGIN_SRC ipython :session assignment1 :results none
WORDS = NAMED.format("words", MONTHS + DAYS + YEAR)
#+END_SRC

This is for the case where the day is placed before them month - /20 March, 2009/.
#+BEGIN_SRC ipython :session assignment1 :results none
BACKWARDS = NAMED.format("backwards", ONE_OR_TWO_DIGITS + SPACE + MONTHS + YEAR)
#+END_SRC

This is the case where slashes are used but only two digits were used for the year (so we're assuming it's in the twentieth century) - /8\slash4\slash98/.
#+BEGIN_SRC ipython :session assignment1 :results none
slashed = SLASH.join([ONE_OR_TWO_DIGITS,
                      ONE_OR_TWO_DIGITS,
                      EXACTLY_TWO_DIGITS])
dashed = DASH.join([ONE_OR_TWO_DIGITS,
                    ONE_OR_TWO_DIGITS,
                    EXACTLY_TWO_DIGITS])
TWENTIETH_CENTURY = NAMED.format("twentieth",
                                 OR.join([slashed, dashed]))
#+END_SRC

This is the case where digits with slashes are used and all four digits are used for the year - /8\slash4\slash1998/.
#+BEGIN_SRC ipython :session assignment1 :results none
NUMERIC = NAMED.format("numeric",
                       SLASH.join([ONE_OR_TWO_DIGITS,
                                   ONE_OR_TWO_DIGITS,
                                   FOUR_DIGITS]))
#+END_SRC

This is the case where only month and year are given as digits - /9\slash2009/. There are two expressions, because the day can be one or two digits.

#+BEGIN_SRC ipython :session assignment1 :results none
NO_PRECEDING_SLASH = NEGATIVE_LOOKBEHIND.format(SLASH)
NO_PRECEDING_SLASH_DIGIT = NEGATIVE_LOOKBEHIND.format(CLASS.format(SLASH + DIGIT))
NO_ONE_DAY = (NO_PRECEDING_SLASH_DIGIT
              + ONE_DIGIT
              + SLASH
              + FOUR_DIGITS)
NO_TWO_DAYS = (NO_PRECEDING_SLASH
               + TWO_DIGITS
               + SLASH
               + FOUR_DIGITS)
NO_DAY_NUMERIC = NAMED.format("no_day_numeric",
                              NO_ONE_DAY
                              + OR
                              + NO_TWO_DAYS
                              )
#+END_SRC

This is the case where only a year was given. This is the hardest case, since you don't want to accidentally match the other cases, but the text preceding and following it could be anything. For the look-behind, all the cases have to have the same number of characters so we can't re-use the other expressions

#+BEGIN_SRC ipython :session assignment1 :results none
CENTURY = GROUP.format('19' + OR + "20") + TWO_DIGITS
DIGIT_SLASH = DIGIT + SLASH
DIGIT_DASH = DIGIT + DASH
DIGIT_SPACE = DIGIT + SPACE
LETTER_SPACE = CLASS.format(LOWER_CASE) + SPACE
COMMA_SPACE = COMMA + SPACE
YEAR_PREFIX = NEGATIVE_LOOKBEHIND.format(OR.join([
    DIGIT_SLASH,
    DIGIT_DASH,
    DIGIT_SPACE,
    LETTER_SPACE,
    COMMA_SPACE,    
]))

YEAR_ONLY = NAMED.format("year_only",
                         YEAR_PREFIX + CENTURY
)
#+END_SRC

These are leftovers that don't really match anything.

#+BEGIN_SRC ipython :session assignment1 :results none
IN_PREFIX = POSITIVE_LOOKBEHIND.format(CLASS.format('iI') + 'n' + SPACE) + CENTURY
SINCE_PREFIX = POSITIVE_LOOKBEHIND.format(CLASS.format("Ss") + 'ince' + SPACE) + CENTURY
AGE = POSITIVE_LOOKBEHIND.format("Age" + SPACE + TWO_DIGITS + COMMA + SPACE) + CENTURY
AGE_COMMA = POSITIVE_LOOKBEHIND.format("Age" + COMMA + SPACE + TWO_DIGITS + COMMA + SPACE) + CENTURY
OTHERS = ['delivery', "quit", "attempt", "nephrectomy", THREE_DIGITS]
OTHERS = [POSITIVE_LOOKBEHIND.format(label + SPACE) + CENTURY for label in OTHERS]
OTHERS = OR.join(OTHERS)
LEFTOVERS_PREFIX = OR.join([IN_PREFIX, SINCE_PREFIX, AGE, AGE_COMMA]) + OR + OTHERS
LEFTOVERS = NAMED.format("leftovers", LEFTOVERS_PREFIX)
#+END_SRC

This is the combined expression for all the dates - the one that should be used to extract them from the data.
#+BEGIN_SRC ipython :session assignment1 :results none
DATE = NAMED.format("date", OR.join([NUMERIC,
                                     TWENTIETH_CENTURY,
                                     WORDS,
                                     BACKWARDS,
                                     CONTRACTION,
                                     NO_DAY,
                                     NO_DAY_NUMERIC,
                                     YEAR_ONLY,
                                     LEFTOVERS]))
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results none
def twentieth_century(date):
    """adds a 19 to the year

    Args:
     date (re.Regex): Extracted date
    """
    month, day, year = date.group(1).split(SLASH)
    year = "19{}".format(year)
    return SLASH.join([month, day, year])
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results none
def take_two(line):
    match = re.search(TWENTIETH_CENTURY, line)
    if match:
        return twentieth_century(match)
    return line
#+END_SRC

* Applying The Grammer

#+BEGIN_SRC ipython :session assignment1 :results none
def extract_and_count(expression, data, name):
    """extract all matches and report the count

    Args:
     expression (str): regular expression to match
     data (pandas.Series): data with dates to extratc
     name (str): name of the group for the expression

    Returns:
     tuple (pandas.Series, int): extracted dates, count
    """
    extracted = data.str.extractall(expression)[name]
    count = len(extracted)
    print("'{}' matched {} rows".format(name, count))
    return extracted, count
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results output
numeric, numeric_count = extract_and_count(NUMERIC, data, 'numeric')
#+END_SRC

#+RESULTS:
: 'numeric' matched 25 rows

#+BEGIN_SRC ipython :session assignment1 :results output
twentieth, twentieth_count = extract_and_count(TWENTIETH_CENTURY, data, 'twentieth')
#+END_SRC

#+RESULTS:
: 'twentieth' matched 100 rows

#+BEGIN_SRC ipython :session assignment1 :results output
words, words_count = extract_and_count(WORDS, data, 'words')
#+END_SRC

#+RESULTS:
: 'words' matched 34 rows

#+BEGIN_SRC ipython :session assignment1 :results output
backwards, backwards_count = extract_and_count(BACKWARDS, data, 'backwards')
#+END_SRC

#+RESULTS:
: 'backwards' matched 69 rows

#+BEGIN_SRC ipython :session assignment1 :results output
contraction_data, contraction = extract_and_count(CONTRACTION, data, 'contraction')
#+END_SRC

#+RESULTS:
: 'contraction' matched 0 rows

#+BEGIN_SRC ipython :session assignment1 :results output
no_day, no_day_count = extract_and_count(NO_DAY, data, 'no_day')
#+END_SRC

#+RESULTS:
: 'no_day' matched 115 rows

#+BEGIN_SRC ipython :session assignment1 :results output
no_day_numeric, no_day_numeric_count = extract_and_count(NO_DAY_NUMERIC, data,
                                                         "no_day_numeric")
#+END_SRC

#+RESULTS:
: 'no_day_numeric' matched 112 rows

#+BEGIN_SRC ipython :session assignment1 :results output
year_only, year_only_count = extract_and_count(YEAR_ONLY, data, "year_only")
#+END_SRC

#+RESULTS:
: 'year_only' matched 15 rows

#+BEGIN_SRC ipython :session assignment1 :results output
leftovers, leftovers_count = extract_and_count(LEFTOVERS, data, "leftovers")
#+END_SRC

#+RESULTS:
: 'leftovers' matched 30 rows

#+BEGIN_SRC ipython :session assignment1 :results output
found = data.str.extractall(DATE)
total_found = len(found.date)

print("Total Found: {}".format(total_found))
print("Remaining: {}".format(len(data) - total_found))
print("Discrepancy: {}".format(total_found - (numeric_count
                                              + twentieth_count
                                              + words_count
                                              + backwards_count
                                              + contraction
                                              + no_day_count
                                              + no_day_numeric_count
                                              + year_only_count
                                              + leftovers_count)))
#+END_SRC

#+RESULTS:
: Total Found: 500
: Remaining: 0
: Discrepancy: 0

#+BEGIN_SRC ipython :session assignment1 :results output
missing = [label for label in data.index if label not in found.index.levels[0]]
try:
    print(missing[0], data.loc[missing[0]])
except IndexError:
    print("all rows matched")
#+END_SRC

#+RESULTS:
: all rows matched

* Unifying the Formats
  To make it simpler, I'm going to use the =mm/dd/yyyy= format for the dates. I'm going to use the extracted series to avoid having different clean-up cases contaminating each other - e.g. dealing with 'January' when the day comes first as opposed to when the month comes first.
** Helper Functions
*** Clean
    This is a generic function to clean up some data. I was initially using it directly, but for cases where the expression and replacement function are used more than once, there are helper functions to make it easier.

#+BEGIN_SRC ipython :session assignment1 :results none
def clean(source, expression, replacement, sample=5):
    """applies the replacement to the source

    as a side-effect shows sample rows before and after

    Args:
     source (pandas.Series): source of the strings
     expression (str): regular expression to match what to replace
     replacement: function or expression to replace the matching expression
     sample (int): number of randomly chosen examples to show

    Returns:
     pandas.Series: the source with the replacement applied to it
    """
    print("Random Sample Before:")
    print(source.sample(sample))
    cleaned = source.str.replace(expression, replacement)
    print("\nRandom Sample After:")
    print(cleaned.sample(sample))
    print("\nCount of cleaned: {}".format(len(cleaned)))
    assert len(source) == len(cleaned)
    return cleaned
#+END_SRC

*** Clean Punctuation
#+BEGIN_SRC ipython :session assignment1 :results none
def clean_punctuation(source, sample=5):
    """removes punctuation

    Args:
     source (pandas.Series): data to clean
     sample (int): size of sample to show

    Returns:
     pandas.Series: source with punctuation removed
    """
    print("Cleaning Punctuation")
    if any(source.str.contains(PUNCTUATION)):
        source = clean(source, PUNCTUATION, EMPTY_STRING)
    return source
#+END_SRC
*** Convert Long Month Names to Three-Letter Names
#+BEGIN_SRC ipython :session assignment1 :results none
LONG_TO_SHORT = dict(January="Jan",
                     February="Feb",
                     March="Mar",
                     April="Apr",
                     May="May",
                     June="Jun",
                     July="Jul",
                     August="Aug",
                     September="Sep",
                     October="Oct",
                     November="Nov",
                     December="Dec")

# it turns out there are spelling errors in the data so this has to be fuzzy
LONG_TO_SHORT_EXPRESSION = OR.join([GROUP.format(month)
                                    + CLASS.format(LOWER_CASE)
                                    + ZERO_OR_MORE
                                    for month in LONG_TO_SHORT.values()])

def long_month_to_short(match):
    """convert long month to short
    
    Args:
     match (re.Match): object matching a long month

    Returns:
     str: shortened version of the month
    """
    return match.group(match.lastindex)
#+END_SRC

This next function is the one you would actually use to make the conversion.

#+BEGIN_SRC ipython :session assignment1 :results none
def convert_long_months_to_short(source, sample=5):
    """convert long month names to short
    
    Args:
     source (pandas.Series): data with months
     sample (int): size of sample to show

    Returns:
     pandas.Series: data with short months
    """
    return clean(source,
                 LONG_TO_SHORT_EXPRESSION,
                 long_month_to_short)
#+END_SRC
*** Add January 1 to year-only dates

#+BEGIN_SRC ipython :session assignment1 :results none
def add_month_date(match):
    """adds 01/01 to years

    Args:
     match (re.Match): object that only matched a 4-digit year

    Returns:
     str: 01/01/YYYY
    """
    return "01/01/" + match.group()
#+END_SRC

And now the function to actually call.

#+BEGIN_SRC ipython :session assignment1 :results none
def add_january_one(source):
    """adds /01/01/ to year-only dates

    Args:
     source (pandas.Series): data with the dates

    Returns:
     pandas.Series: years in source with /01/01/ added
    """
    return clean(source, YEAR_ONLY, add_month_date)
#+END_SRC
*** Two-Digit Numbers
    This makes sure that there are exactly two digits in a number, adding a leading zero if needed.
#+BEGIN_SRC ipython :session assignment1 :results none
two_digit_expression = GROUP.format(ONE_OR_TWO_DIGITS) + POSITIVE_LOOKAHEAD.format(SLASH)

def two_digits(match):
    """add a leading zero if needed

    Args:
     match (re.Match): match with one or two digits

    Returns:
     str: the matched string with leading zero if needed
    """
    # for some reason the string-formatting raises an error if it's a string
    # so cast it to an int
    return "{:02}".format(int(match.group()))
#+END_SRC

This is the function to call for the case where the number is followed by a slash (e.g. =2/=).

#+BEGIN_SRC ipython :session assignment1 :results none
def clean_two_digits(source, sample=5):
    """makes sure source has two-digits
    
    Args:
     source (pandas.Series): data with digit followed by slash
     sample (int): number of samples to show

    Returns:
     pandas.Series: source with digits coerced to two digits
    """
    return clean(source, two_digit_expression, two_digits, sample)
#+END_SRC

This is like =clean_two_digits= but it doesn't check for the trailing slash. Use this if you have an isolated column of numbers that need to be two-digits.

#+BEGIN_SRC ipython :session assignment1 :results none
def clean_two_digits_isolated(source, sample=5):
    """cleans two digits that are standalone

    Args:
     source (pandas.Series): source of the data
     sample (int): number of samples to show

    Returns:
     pandas.Series: converted data
    """
    return clean(source, ONE_OR_TWO_DIGITS, two_digits, sample)
#+END_SRC

*** Cleaning Up Months
    These clean up and convert written months (e.g. change =Aug= to =08=).

#+BEGIN_SRC ipython :session assignment1 :results none
digits = ("{:02}".format(month) for month in range(1, 13))
MONTH_TO_DIGITS = dict(zip(MONTH_PREFIXES, digits))
SHORT_MONTHS_EXPRESSION = OR.join((GROUP.format(month) for month in MONTH_TO_DIGITS))
def month_to_digits(match):
    """converts short month to digits

    Args:
     match (re.Match): object with short-month

    Returns:
     str: month as two-digit number (e.g. Jan -> 01)
    """
    return MONTH_TO_DIGITS[match.group()]
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results none
def convert_short_month_to_digits(source, sample=5):
    """converts three-letter months to two-digits

    Args:
     source (pandas.Series): data with three-letter months
     sample (int): number of samples to show

    Returns:
     pandas.Series: source with short-months coverted to digits
    """
    return clean(source,
                 SHORT_MONTHS_EXPRESSION,
                 month_to_digits,
                 sample)
#+END_SRC

This function runs the previous three and is the main one that should be used. The others can be run individually for troubleshooting, though.
#+BEGIN_SRC ipython :session assignment1 :results none
def clean_months(source, sample=5):
    """clean up months (which start as words)

    Args:
     source (pandas.Series): source of the months
     sample (int): number of random samples to show
    """
    cleaned = clean_punctuation(source)
    
    print("Converting long months to short")
    cleaned = clean(cleaned,
                    LONG_TO_SHORT_EXPRESSION,
                    long_month_to_short, sample)

    print("Converting short months to digits")
    cleaned = clean(cleaned,
                    SHORT_MONTHS_EXPRESSION,
                    month_to_digits, sample)
    return cleaned
#+END_SRC
*** Frame To Series
    This is for the case where the date-fields were broken up into columns in a data-frame.
#+BEGIN_SRC ipython :session assignment1 :results none
def frame_to_series(frame, index_source, samples=5):
    """re-combines data-frame into a series

    Args:
     frame (pandas.DataFrame): frame with month, day, year columns
     index_source (pandas.series): source to copy index from
     samples (index): number of random entries to print when done

    Returns:
     pandas.Series: series with dates as month/day/year
    """
    combined = frame.month + SLASH + frame.day + SLASH + frame.year
    combined.index = index_source.index
    print(combined.sample(samples))
    return combined
#+END_SRC

** Year Only
   For the case where there is only a year, I'll add January 1 to the dates.

#+BEGIN_SRC ipython :session assignment1 :results output
year_only_cleaned = add_january_one(year_only)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
     match
495  0        1979
483  0        1995
481  0        1974
462  0        1988
470  0        1983
Name: year_only, dtype: object

Random Sample After:
     match
478  0        01/01/1993
496  0        01/01/2006
480  0        01/01/2013
462  0        01/01/1988
466  0        01/01/1981
Name: year_only, dtype: object

Count of cleaned: 15
#+end_example

** Leftovers
   These were the odd cases that didn't seem to have a real pattern. Since I used a negative lookbehind they only have the years in them, like the other year-only cases.

#+BEGIN_SRC ipython :session assignment1 :results output
leftovers_cleaned = add_january_one(leftovers)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
     match
456  0        2000
471  0        1999
461  0        1991
490  0        2007
469  0        2003
Name: leftovers, dtype: object

Random Sample After:
     match
457  0        01/01/2001
491  0        01/01/2009
475  0        01/01/2015
456  0        01/01/2000
459  0        01/01/1998
Name: leftovers, dtype: object

Count of cleaned: 30
#+end_example

#+BEGIN_SRC ipython :session assignment1 :results output
cleaned = pandas.concat([year_only_cleaned, leftovers_cleaned])
print(len(cleaned))
#+END_SRC

#+RESULTS:
: 45

** No Day Numeric
   This is for the case where the date is formatted with slashes and there are no day-values. To make the months uniform I'm going to make them all two-digits first.

#+BEGIN_SRC ipython :session assignment1 :results output
no_day_numeric_cleaned = clean_two_digits(no_day_numeric)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
     match
364  0        11/2010
423  0        12/1986
434  0        10/1978
409  0        10/1994
441  0         9/1980
Name: no_day_numeric, dtype: object

Random Sample After:
     match
385  0        07/1989
357  0        10/1993
414  0        04/2004
375  0        06/1973
435  0        12/1989
Name: no_day_numeric, dtype: object

Count of cleaned: 112
#+end_example

Now I'll add the day.

#+BEGIN_SRC ipython :session assignment1 :results output
no_day_numeric_cleaned = clean(no_day_numeric_cleaned,
                               SLASH,
                               lambda m: "/01/")
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
     match
412  0        03/1990
382  0        09/1975
365  0        07/1997
443  0        09/2000
384  0        05/1999
Name: no_day_numeric, dtype: object

Random Sample After:
     match
440  0        06/01/1989
442  0        09/01/1992
423  0        12/01/1986
454  0        07/01/1982
406  0        12/01/1994
Name: no_day_numeric, dtype: object

Count of cleaned: 112
#+end_example

And add it to the total.

#+BEGIN_SRC ipython :session assignment1 :results none
original = len(cleaned)
cleaned = pandas.concat([cleaned, no_day_numeric_cleaned])
assert len(cleaned) == no_day_numeric_count + original
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results output
print(len(cleaned))
#+END_SRC

#+RESULTS:
: 157

** No Day
   This is for cases like /Mar 2011/ where no day was given. We're going to assume that it's the first day of the month for each case.

#+BEGIN_SRC ipython :session assignment1 :results output
no_day_cleaned = clean_months(no_day)
#+END_SRC

#+RESULTS:
#+begin_example
Cleaning Punctuation
Random Sample Before:
     match
292  0        November 1995
232  0            July 1977
312  0        February 1989
239  0             Feb 1978
307  0            July 2006
Name: no_day, dtype: object

Random Sample After:
     match
323  0          March 1973
286  0        January 2013
240  0            May 2011
310  0            Oct 1992
336  0          March 1978
Name: no_day, dtype: object

Count of cleaned: 115
Converting long months to short
Random Sample Before:
     match
263  0        September 1981
253  0              Feb 2016
258  0              Apr 1976
250  0              May 2005
273  0         February 2010
Name: no_day, dtype: object

Random Sample After:
     match
298  0        Jan 1993
285  0        Sep 1983
278  0        Sep 1974
243  0        Sep 2012
331  0        Dec 1993
Name: no_day, dtype: object

Count of cleaned: 115
Converting short months to digits
Random Sample Before:
     match
332  0        Jun 1974
328  0        May 2001
254  0        Aug 1979
242  0        Nov 2010
321  0        Jun 1999
Name: no_day, dtype: object

Random Sample After:
     match
261  0        10 1986
317  0        03 1975
254  0        08 1979
298  0        01 1993
301  0        12 1992
Name: no_day, dtype: object

Count of cleaned: 115
#+end_example

Now we need to replace the spaces with the days.

#+BEGIN_SRC ipython :session assignment1 :results output
no_day_cleaned = clean(no_day_cleaned,
                       SPACE + ONE_OR_MORE,
                       lambda match: "/01/")
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
     match
292  0        11 1995
236  0        05 1995
341  0        11 2007
280  0        07 1985
314  0        01 2007
Name: no_day, dtype: object

Random Sample After:
     match
342  0        03/01/1976
274  0        04/01/1985
294  0        02/01/1983
295  0        03/01/1983
283  0        02/01/1977
Name: no_day, dtype: object

Count of cleaned: 115
#+end_example

Now we can add it to the cleaned.

#+BEGIN_SRC ipython :session assignment1 :results output
original = len(cleaned)
cleaned = pandas.concat([cleaned, no_day_cleaned])
print(len(cleaned))
#+END_SRC

#+RESULTS:
: 272

Now to make sure we're where we expect we are.

#+BEGIN_SRC ipython :session assignment1 :results none
assert len(cleaned) == no_day_count + original
#+END_SRC

** Contraction
   There were no matches for the contraction so I'll ignore it for now. 
** Backwards
   This is the case where the day comes first. The first thing I'll do is split them up.

#+BEGIN_SRC ipython :session assignment1
frame = pandas.DataFrame(backwards.str.split().tolist(),
                         columns="day month year".split())
frame.head()
#+END_SRC

#+RESULTS:
:   day month  year
: 0  24   Jan  2001
: 1  10   Sep  2004
: 2  26   May  1982
: 3  28  June  2002
: 4  06   May  1972

The next thing to do is to make sure the days all have two digits.

#+BEGIN_SRC ipython :session assignment1 :results output
frame.day = clean_two_digits(frame.day)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
10    10
43    13
34    26
67    06
52    18
Name: day, dtype: object

Random Sample After:
59    11
67    06
9     14
68    18
62    14
Name: day, dtype: object

Count of cleaned: 69
#+end_example

Next comes the months. This is basically the same problem as with the /no day/ case so I'll re-use some of the code for that.


#+BEGIN_SRC ipython :session assignment1 :results output
frame.month = clean_months(frame.month)
#+END_SRC

#+RESULTS:
#+begin_example
Cleaning Punctuation
Converting long months to short
Random Sample Before:
26    June
5      Oct
19     Oct
29     Mar
7      Nov
Name: month, dtype: object

Random Sample After:
42    Oct
22    May
28    Jan
61    Oct
56    Aug
Name: month, dtype: object

Count of cleaned: 69
Converting short months to digits
Random Sample Before:
17    Jan
33    Aug
60    Aug
58    May
4     May
Name: month, dtype: object

Random Sample After:
41    11
52    01
18    10
8     06
65    08
Name: month, dtype: object

Count of cleaned: 69
#+end_example

Now we need to combine them back together. In hindsight it might have been easier to convert everything into data frames instead of the other way around. Or maybe not. Since we want the indexes from the original data as our final answer I also have to copy the index from the original series

#+BEGIN_SRC ipython :session assignment1 :results output
backwards_cleaned = frame_to_series(frame, backwards)
#+END_SRC

#+RESULTS:
:      match
: 141  0        05/30/2016
: 153  0        01/13/1972
: 133  0        06/28/1994
: 140  0        02/14/1995
: 156  0        05/26/1974
: dtype: object

: 140  0        02/14/1995
: 177  0        01/18/1990
: 156  0        05/26/1974
: 189  0        10/21/1977
: 160  0        10/21/2007
: dtype: object

No it gets added to the combined series.

#+BEGIN_SRC ipython :session assignment1 :results none
original = len(cleaned)
cleaned = pandas.concat([cleaned, backwards_cleaned])
assert len(cleaned) == original + backwards_count
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results output
print(len(cleaned))
#+END_SRC

#+RESULTS:
: 341

** Words
   Since working with the data frame was easier than I though it would be I'll do that again.

#+BEGIN_SRC ipython :session assignment1 :results output
frame = pandas.DataFrame(words.str.split().tolist(), columns="month day year".split())
print(frame.head())
#+END_SRC

#+RESULTS:
:       month  day  year
: 0     April  11,  1990
: 1       May  30,  2001
: 2       Feb  18,  1994
: 3  February  18,  1981
: 4  October.  11,  2013

First we'll clean out the months.

#+BEGIN_SRC ipython :session assignment1 :results output
frame.month = clean_months(frame.month)
#+END_SRC

#+RESULTS:
#+begin_example
Cleaning Punctuation
Random Sample Before:
18        July
0        April
21      August
7     December
31        June
Name: month, dtype: object

Random Sample After:
1      May
25     Dec
6     July
24     May
30    July
Name: month, dtype: object

Count of cleaned: 34
Converting long months to short
Random Sample Before:
1         May
4     October
8         May
13     August
17      April
Name: month, dtype: object

Random Sample After:
33    Sep
19    Jul
26    Jun
30    Jul
24    May
Name: month, dtype: object

Count of cleaned: 34
Converting short months to digits
Random Sample Before:
26    Jun
2     Feb
29    Oct
13    Aug
32    Jan
Name: month, dtype: object

Random Sample After:
24    05
9     09
13    08
4     10
28    05
Name: month, dtype: object

Count of cleaned: 34
#+end_example

Now we'll clean up the punctuation for the days.

#+BEGIN_SRC ipython :session assignment1 :results output
frame.day = clean_punctuation(frame.day)
#+END_SRC

#+RESULTS:
#+begin_example
Cleaning Punctuation
Random Sample Before:
16    11,
5      24
23    13,
21    14,
30    25,
Name: day, dtype: object

Random Sample After:
2     18
15    25
30    25
33    15
26    25
Name: day, dtype: object

Count of cleaned: 34
#+end_example

So, what do we have so far?

#+BEGIN_SRC ipython :session assignment1
frame.head()
#+END_SRC

#+RESULTS:
:   month day  year
: 0    04  11  1990
: 1    05  30  2001
: 2    02  18  1994
: 3    02  18  1981
: 4    10  11  2013

At this point we need to combine everything with a slash and restore the index.

#+BEGIN_SRC ipython :session assignment1 :results output
words_cleaned = frame_to_series(frame, words)
#+END_SRC

#+RESULTS:
:      match
: 209  0        07/25/1983
: 221  0        10/18/1980
: 227  0        09/15/2011
: 201  0        12/23/1999
: 197  0        02/18/1981
: dtype: object

Now we'll add it to the total.

#+BEGIN_SRC ipython :session assignment1 :results output
original = len(cleaned)
cleaned = pandas.concat([cleaned, words_cleaned])
assert len(cleaned) == original + words_count
print(len(cleaned))
#+END_SRC

#+RESULTS:
: 375

** Twentieth Century
   We'll do the same trick with creating a dataframe. The first thing, though, is to replace the dashes with slashes.

#+BEGIN_SRC ipython :session assignment1 :results output
print(twentieth.iloc[21])
twentieth_cleaned = twentieth.str.replace(DASH, SLASH)
print(cleaned.iloc[21])
#+END_SRC

#+RESULTS:
: 4-13-82
: 01/01/1991

Now, we'll create the frame.

#+BEGIN_SRC ipython :session assignment1 :results output
frame = pandas.DataFrame(twentieth_cleaned.str.split(SLASH).tolist(),
                         columns=["month", "day", "year"])
print(frame.head())
#+END_SRC   

#+RESULTS:
:   month day year
: 0    03  25   93
: 1     6  18   85
: 2     7   8   71
: 3     9  27   75
: 4     2   6   96

*** Months
    The months need to be converted to two-digits.

#+BEGIN_SRC ipython :session assignment1 :results output
frame.month = clean_two_digits_isolated(frame.month)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
43     6
50    02
84     8
49     8
27     4
Name: month, dtype: object

Random Sample After:
11    04
29    03
27    04
1     06
78    11
Name: month, dtype: object

Count of cleaned: 100
#+end_example

As do the days.

#+BEGIN_SRC ipython :session assignment1 :results output
frame.day = clean_two_digits_isolated(frame.day)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
73    19
62     5
98    04
84    22
64    04
Name: day, dtype: object

Random Sample After:
81    22
6     18
38    12
48    24
46    14
Name: day, dtype: object

Count of cleaned: 100
#+end_example

#+BEGIN_SRC ipython :session assignment1
frame.head()
#+END_SRC

#+RESULTS:
:   month day year
: 0    03  25   93
: 1    06  18   85
: 2    07  08   71
: 3    09  27   75
: 4    02  06   96

Now we have to add =19= to each of the years.

#+BEGIN_SRC ipython :session assignment1 :results output
frame.year = clean(frame.year, TWO_DIGITS, lambda match: "19" + match.group())
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
70    82
38    94
47    73
26    72
51    87
Name: year, dtype: object

Random Sample After:
85    1974
33    1975
84    1983
15    1998
45    1986
Name: year, dtype: object

Count of cleaned: 100
#+end_example

Now we have to join them back up.

#+BEGIN_SRC ipython :session assignment1 :results output
twentieth_cleaned = frame_to_series(frame, twentieth)
#+END_SRC

#+RESULTS:
:      match
: 122  0        11/05/1990
: 16   0        04/12/1982
: 5    0        07/06/1979
: 49   0        02/28/1975
: 12   0        08/01/1998
: dtype: object

#+BEGIN_SRC ipython :session assignment1 :results none
original = len(cleaned)
cleaned = pandas.concat([cleaned, twentieth_cleaned])
#+END_SRC

#+BEGIN_SRC ipython :session assignment1 :results none
assert len(cleaned) == original + twentieth_count
#+END_SRC

** Numeric
   The final category is dates with the format =mm/dd/yyyy=.

#+BEGIN_SRC ipython :session assignment1 :results output
print(numeric.head())
#+END_SRC

#+RESULTS:
:     match
: 14  0         5/24/1990
: 15  0         1/25/2011
: 17  0        10/13/1976
: 24  0        07/25/1984
: 30  0        03/31/1985
: Name: numeric, dtype: object

We should check and make sure there are no dashes here.

#+BEGIN_SRC ipython :session assignment1 :results output
has_dashes = numeric.str.contains(DASH)
print(numeric[has_dashes])
#+END_SRC

#+RESULTS:
: Series([], Name: numeric, dtype: object)

It looks like it doesn't so we'll skip this check.

#+BEGIN_SRC ipython :session assignment1 :results output
frame = pandas.DataFrame(numeric.str.split(SLASH).tolist(),
                         columns="month day year".split())
print(frame.head())
#+END_SRC

#+RESULTS:
:   month day  year
: 0     5  24  1990
: 1     1  25  2011
: 2    10  13  1976
: 3    07  25  1984
: 4    03  31  1985

#+BEGIN_SRC ipython :session assignment1 :results output
frame.month = clean_two_digits_isolated(frame.month)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
2     10
22     2
24     4
20     4
13    11
Name: month, dtype: object

Random Sample After:
1     01
7     04
14    01
8     02
21    07
Name: month, dtype: object

Count of cleaned: 25
#+end_example

#+BEGIN_SRC ipython :session assignment1 :results output
frame.day = clean_two_digits_isolated(frame.day)
#+END_SRC

#+RESULTS:
#+begin_example
Random Sample Before:
13     3
18    08
20    11
0     24
19    08
Name: day, dtype: object

Random Sample After:
4     31
24    27
23    20
11    20
20    11
Name: day, dtype: object

Count of cleaned: 25
#+end_example

#+BEGIN_SRC ipython :session assignment1 :results output
numeric_cleaned = frame_to_series(frame, numeric)
#+END_SRC

#+RESULTS:
:     match
: 45  0        02/15/1998
: 77  0        01/05/1999
: 94  0        12/08/1990
: 14  0        05/24/1990
: 55  0        10/11/1987
: dtype: object

#+BEGIN_SRC ipython :session assignment1 :results output
original = len(cleaned)
cleaned = pandas.concat([cleaned, numeric_cleaned])
assert len(cleaned) == original + numeric_count
print(len(cleaned))
#+END_SRC

#+RESULTS:
: 500

At this point it looks like we've cleaned all the cases.

** Re-combining The Cleaned
   Because these notebooks can execute things out of order I'm going to create one monolithic concatenation and ignore the one that I was using to keep the running total.

#+BEGIN_SRC ipython :session assignment1 :results output
cleaned = pandas.concat([numeric_cleaned,
                         twentieth_cleaned,
                         words_cleaned,
                         backwards_cleaned,
                         no_day_cleaned,
                         no_day_numeric_cleaned,
                         year_only_cleaned,
                         leftovers_cleaned,
])
print(len(cleaned))
print(cleaned.head())
assert len(cleaned) == len(data)
#+END_SRC

#+RESULTS:
: 500
:     match
: 14  0        05/24/1990
: 15  0        01/25/2011
: 17  0        10/13/1976
: 24  0        07/25/1984
: 30  0        03/31/1985
: dtype: object

* Convert to Datetimes
#+BEGIN_SRC ipython :session assignment1 :results output
print(cleaned.head())
datetimes = pandas.to_datetime(cleaned, format="%m/%d/%Y")
print(datetimes.head())
#+END_SRC

#+RESULTS:
#+begin_example
    match
14  0        05/24/1990
15  0        01/25/2011
17  0        10/13/1976
24  0        07/25/1984
30  0        03/31/1985
dtype: object
    match
14  0       1990-05-24
15  0       2011-01-25
17  0       1976-10-13
24  0       1984-07-25
30  0       1985-03-31
dtype: datetime64[ns]
#+end_example

#+BEGIN_SRC ipython :session assignment1 :results output
sorted_dates = datetimes.sort_values()
print(sorted_dates.head())
#+END_SRC

#+RESULTS:
:     match
: 9   0       1971-04-10
: 84  0       1971-05-18
: 2   0       1971-07-08
: 53  0       1971-07-11
: 28  0       1971-09-12
: dtype: datetime64[ns]

#+BEGIN_SRC ipython :session assignment1 :results output
print(sorted_dates.tail())
#+END_SRC

#+RESULTS:
:      match
: 231  0       2016-05-01
: 141  0       2016-05-30
: 186  0       2016-10-13
: 161  0       2016-10-19
: 413  0       2016-11-01
: dtype: datetime64[ns]

The grader wants a Series with the indices of the original data put in the order of the sorted dates.

#+BEGIN_SRC ipython :session assignment1 :results output
answer = pandas.Series(sorted_dates.index.labels[0])
print(answer.head())
#+END_SRC

#+RESULTS:
: 0     9
: 1    84
: 2     2
: 3    53
: 4    28
: dtype: int16

* The date_sorter Function
  This is the function called by the grader. Since the work was done outside of it we just need to make sure that it returns our answer.

#+BEGIN_SRC ipython :session assignment1 :results none
def date_sorter():
    return answer
#+END_SRC

*note:* This produced a 94% score, so there are still some cases not correctly handled.
